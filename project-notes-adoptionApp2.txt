project-notes-adoptionApp.txt

made our boiler plate react app (in the current dir.) with:
npx create-react-app adoption-app
& created the github repository so we can work from different devices;

We're using the udemy videos now, so this project/part starts on video 26 of the course:
"The React Testing Library Bootcamp - The Developer Guide"  by Laith Harb
https://www.udemy.com/course/the-react-testing-library-bootcamp/learn/lecture/29987370#overview

So for time stamps I will have to say the video, then the time if needed, but I can try to wrap up each video;

~    ~    ~    ~    ~    ~    ~    ~    ~    ~    ~    ~    ~    ~
____________________________________________________________________

about the app:
more complicated than the signup-form app, so we'll learn more about RTL

Users will be able to look at the different cats, see the cats name, picture, and contact info (phone & email)
if they're insterested in adopting the cat; They also can 'favorite' cats they like by clicking a little heart
icon that gets filled out if they click on it (can favorite multiple cats);
Users can filter the cats by gender (M/F), or by favorites/!favorites, or a combo of the two filters;

Addtionally, the data that is presented in the 'cat cards' won't be coming from our react app directly,
the data will come from http requests to another server;
We can inspect the page in our browser.. (maybe just in chrome, which might rule out using my old ass MBAir, or maybe
I can still do it if I use an old version of chrome and just don't go beyond local host on the outdated chrome..?)
so inspect the page, go to network tab, refresh the page, you can find a request called 'cats' which shows data
coming  back from a server;

We'll also learn how to handle http requests in our RTL tests, which is good.

~    ~    ~    ~    ~

vid 27: Breakdown of App
This is relatively large application so we can't just put all the code in the one App.js file like we did for the
signup-form-app; We're going to have to split this app into multiple components;

What are those components going to be? What will occur in those components?
The most obvious component--> The 'card' component;
1. "Card" component will display each individual cat;
This card component will take in some props (probably the best way to get the data into the component):
Name of cat
contact phone number
contact email
Favored or !Favored       --> and the card will take in these props, but other than that, it will be a
straightforward component

2. "Cards" component is where all the individual "Card" components will live;
Basically a big component to house the smaller components--> Cards is parent of Card in heirarchy;
Multiple 'card' components will live in larger 'cards' component, not sure how I can restate this;
-"Cards" will get an array of objects that will contain information about the cats, and it will Map over them,
and forEach Object, it's going to render a "Card" component; so also relatively simple, right?

3. "Filter" component which will allow users to filter the cats

4. Overall component to group everything together will be called the "Pets" component
'Pets' will be responsible for making the http requests to our server in order to get the
'cat data'. Once it gets the 'cat data' it will filter it based on the parameters passed
from the 'Filter' component, then it will pass that filtered data to the 'Cards' component,
which will render that data as individual 'Card' components;

The web app/page will be structured something like this crude ascii diagram:

_________________________________________________
|             ___________________               |      ◄|'Pets'
| 'Filter'    |  {Card}  {Card} |   ◄ 'Cards'   |      ◄|
|    ▼        |  {Card}  {Card} |               |      ◄|
|             |  {Card} ...     |               |      ◄|
|             |_________________|               |      ◄|
|_______________________________________________|


Where do we start to build all of these things? ?  We will start with the most basic component/element
of our app, which is the 'Card'--in the next video;

(video:)
#28
We'll start by running npx create-react-app adoption-app if we haven't already done so,
@30 sec:
then we'll make a 'components' folder w/in the src directory,
& this where all our components are going to live;

mkdir src/components/Card
touch Card.js

we add a default function to return an empty div at this point;
#28 @1.28 --> discussion of organinzing the test files for a project;
We can put our .test files anywhere and Jest will detect them, but a common convention
is to create a new folder (within the folder that has the files we want to test) called "__test__"
pwd --> components/Card
mkdir __test__
touch Card.test.js
-----
add our imports to the new 'test' file so we can access the 'Card' component file, and
also a couple things from @testing-library/react -- render & screen
'render' so we render our virtual DOM for testing it,
'screen' so we can access components in the DOM -- see the RTL documentation:
https://testing-library.com/docs/queries/about/#screen

I think 'screen' basically acts as a shortcut for 'document.body' (?) & probably adds some extra functionality;

#28 @2.55  -- so what do we want to test?
first let`s test that we're rendering the name, email, & phone into a Card component;

We also want to remove the default test file "App.test.js" just to remove that clutter
and also the default test that will pass

we would run:
npm run test

but that command wasn't recognized, so I ran: 'npm i' to see if that will correct the issue;
tried again and got a different error: "Test suite failed to run"
Maybe he will address this in the video?

It seems like a npm/node version issue; Since I created on the MBA, I don't think it's using the same version
as my dev MBP;
Maybe I need to create-react-app again on the dev MBP;
I tried re-scaffolding the app from my dev MBP, but still got the same error;
Ultimately I had to run this command to explicitly install a specific version of jest-watch-typeahead:
npm i -D --exact jest-watch-typeahead@0.6.5

although I wonder if it would work if I simply said "npm i jest-watch-typeahead"
anyway, we're back in business;  We don't have any asserts yet, so nothing to pass/fail;

Part of the problem was that we weren't exporting the Card component correctly;
we had:  export default Card = () => { ...}
we needed to break it up into: const Card = () => {... };  export default Card;

* interesting note-- the test works when Card.js is like this:

const Card = () => {
    return <div></div>;
};

export default Card;

******************
But NOT like this:
******************
export default Card;
const Card = () => {
    return <div></div>;
};
******************
& NOT like this:   (this one makes sense, b/c it's reading it all as one line essentially)
******************
const Card = () => {
    return <div></div>;
}
export default Card;

*****************************
cat data, my cat data          
He's using unsplash.com for his cat images, but I can't seem to access the pictures there, maybe just on the VPN, idk,
but have to gather some cat image urls from google images; Here are some cat image URLs:
https://i.natgeofe.com/n/548467d8-c5f1-4551-9f58-6817a8d2c45e/NationalGeographic_2572187_2x1.jpg
https://cdn.theatlantic.com/thumbor/W544GIT4l3z8SG-FMUoaKpFLaxE=/0x131:2555x1568/1600x900/media/img/mt/2017/06/shutterstock_319985324/original.jpg
https://www.humanesociety.org/sites/default/files/styles/1240x698/public/2020-07/kitten-510651.jpg?h=f54c7448&itok=ZhplzyJ9
http://www.alleycat.org/wp-content/uploads/2019/03/FELV-cat.jpg
https://cdn.britannica.com/39/7139-050-A88818BB/Himalayan-chocolate-point.jpg
https://media.npr.org/assets/img/2021/08/11/gettyimages-1279899488_wide-f3860ceb0ef19643c335cb34df3fa1de166e2761-s1100-c50.jpg
https://www.fundacion-affinity.org/sites/default/files/los-10-sonidos-principales-del-gato-fa.jpg
https://upload.wikimedia.org/wikipedia/commons/b/bc/Juvenile_Ragdoll.jpg
https://253qv1sx4ey389p9wtpp9sj0-wpengine.netdna-ssl.com/wp-content/uploads/2022/09/08_22_Winery_Cats_HERO_GettyImages_475462958_1920x1280.jpg
https://arc-anglerfish-washpost-prod-washpost.s3.amazonaws.com/public/WALN4MAIT4I6VLRIPUMJQAJIME.jpg

We're passing some props into our mocked 'Card' component:
name
phone
email
image
favoured

We manually put those props into a rendered div in our test, so then we expect those props to be in the DOM/screen

#28 @9min we put in our first test, and mine passes, but his failed... he said it should fail... not sure why that is;
uh... ok, now it's failing.  no idea what this is about but we're up to speed with him at 9min;
later...
I tried running the test again and it said 'no new tests related to changed files since last commit'
so it wouldn't run the test I we had; The message also said to 'press a to run all tests' so I did & that runs them;

copy first test to use as scaffolding for new test;
If we're copying stuff though, should we add the Card to a 'beforeEach' ?
That could be a problem though, b/c our Card component has some props in it, & if we put it in a 'beforeEach' hook,
those props would always be the same, and we might not want that;
-So what's the solution?   --> We can make a function/variable to create our Card component <---
We made a const called 'cardProps', and we add that to our 'Card' (while destructuring it to get all the props)

//if we want to rename one of the props, we do it like this:
render(
            <Card
                {...cardProps}
                name: "newNameOverwritesCardProps"
            />
        )//render

-           -           -           -           -

We added the tests for name, phone, & email;
Challenge--> make the test to test for the image!  Then proceed to #29 video;

-----------------------------------------------------
#29 do the challenge: create test for image src;
I think I can use the alt text, and I can use--> expect(image).toHaveAttribute('src', 'the_url')
#30--solution:
...so kind of cool, he did both of the things I tried to do in one 'expect'
// get by alt text gives us the element...
// then we look at that element and see that it matches what we have in our Card component,
// which is coming from the cardProps object
// which has a property called 'image', which has a property called 'url'

--->   expect(screen.getByAltText(/cute cat/i).src).toBe(cardProps.image.url);

*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
* onto #31   *            *            *            *            *
*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
Now we're going to write the minimum amount of code we have to in order for
 our tests to pass;
1st thing we'll do is pass in some props to our Card, so we put {} in the () to pass in an object aka 'stuff';

We added some divs and classNames for the divs, and put variables for each of the fields that will go in a Card component;
We also went and downloaded his CSS file and copied it into a new CSS file
in the components/Card folder.  His file is on github:
https://raw.githubusercontent.com/harblaith7/React-Testing-Library-Udemy-Course/main/02-Cat-Adoption-App/client/src/components/Card/Card.css

So we have all our 'Card' tests passing and we added a CSS file--move on to #32

#32:  now we need to add the tests for the heart/favorite aspect of the Card component;
When we 1st click it should fill the heart, if we click again it should clear the heart;

#33: red green testing style--> we wrote the tests 1st, they are initially red/failed, & now
we will write the code to make them pass green/pass
Part of doing this means we have to DL the 2 svg files for heartFilled.svg
& heartOutlined.svg  & put them in a new folder 'svgs' in our ~/src folder;

https://github.com/harblaith7/React-Testing-Library-Udemy-Course/blob/main/02-Cat-Adoption-App/client/src/svgs/heartFilled.svg

https://github.com/harblaith7/React-Testing-Library-Udemy-Course/blob/main/02-Cat-Adoption-App/client/src/svgs/heartOutlined.svg

then we have to import them into our Card.js file like so:
import heartFilled from "../../svgs/heartFilled.svg"
import heartOutlined from "../../svgs/heartOutlined.svg"

@3.08 of #33, he has 6 tests passed & 1 fail;
I have 3 failing 4 passed.
installed meld to compare: https://yousseb.github.io/meld/

after some serious formatting and stuff, I found that I had the tests for
the hearts using "getAllByAltText" instead of "getByAltText" !!
vsCode autofilling messed me up there & i didn't notice it;
Now we're on the same page with Laith again;

Our only failed test is testing the state of 'favoured' which we don't have a state yet,
so now we'll create a local state to store the status of 'favoured'

How did we do this?
* we created a const with "useState" to store the state that is an array with 2 values;
* We have to have "useState" to get the interaction from the user;
* We set a ternary statement inside the button, so if "isFavoured" is true, we have the heart, and if not the outlined heart;
* onClick we call a function which toggles the value ...
... but why do we even need the 2nd value in this array..? And we're calling "setIsFavoured" like a function inside another
function called "toggleFavoured" ... I don't understand this part;
Maybe we can remove setIsFavoured?
    //setting up a localState w/ initial value from our props that came in with anon func

    const[isFavoured, setIsFavoured] = useState(favoured);  <------ this is just how you use the `'useState' hook`
    const toggleFavoured = () => {
        setIsFavoured(!isFavoured);
    };
    return <div className="card">
        <div className="card-header">
            <img src={image.url} alt={image.alt} className="card-img"/>
            {/* in the card-header we use a ternary expression to show the right heart svg */}
            <button className="heart" onClick={toggleFavoured}>
                {isFavoured ? (
                    <img src={heartFilled} alt="filled heart" />
                ) : <img src={heartOutlined} alt="outlined heart" />}
            </button>
        </div>

I tried this which didn't work, I guess I need to read about toggling state onClick with javascript;
    const toggleFavoured = () => {
        if (isFavoured) isFavoured = false;
        else isFavoured = true;
    };

I think I really need to understand this, I'll try to find something on this
maybe I need to read/try this:
https://designcode.io/react-hooks-handbook-toggle-a-state

it's called the "useState hook" and this is just how it's done;
maybe I can find some more examples, but this is just the syntax;

-           -           -           -           -           -           -           -           -
-           -           -           -           -           -           -           -           -

@34:   time for some manual testing & actually use our code in the App.js file;

go to App.js and remove all the stuff in the function App() "return" area and the App.css import;
we put a div for Card in the return statement, and we pass in the props we used in our Card.test.js file;
WE have to update the formatting to use "=" instead of ":" and remove the commas;
@1.18 of 34
We want to start the app, so we do "npm run start" from our terminal;
we needed to add the import for Card.css to Card.js for the styling to work though;
We also need to add the box shadow to the css file for .card maybe;
Now we have our Card component and the heart is behaving as expected, so that's good!

@35: Heading into creating the tests/code for the "Cards" component, & a big concept that we'll
cover is querying for multiple components, I'd guess to test that we have multiple "Card" components rendered?
@36: getting into it;
WE want to remove the "Card" component we put into the App.js file since this isn't the way we want the final
product to display anyway, it was just for manual debugging purposes;
-mkdir ~/src/Cards
-touch Cards.js

-mkdir ~/src/Cards/__test__
-touch Cards.test.js

when we test the 'Cards' component, we will also test anything that it renders, this is as opposed to
what is called 'shallow rendering' which would only render the parent component and not the children;
Shallow rendering isn't really a thing in RTL though, and it's probably for the best according to Laith;

We start writing the tests after adding imports for RTL and Cards-->
import { render, screen } from "@testing-library/react"
import Cards from "../Cards"

we also need some test data, so we can mkdir ~/src/mocks && touch cats.json
or just DL his file and make the directory for it;
I made directory and file and copy pasted raw from github:
https://raw.githubusercontent.com/harblaith7/React-Testing-Library-Udemy-Course/main/02-Cat-Adoption-App/client/src/mocks/cats.json

in our first test we first render()  the Cards component --> render(<Cards />)
and we pass in the cats array (as 'cats') as our data --> render(<Cards cats={cats}/>)
--now the question is--> how can we query for the 'Card' components that will be inside our 'Cards' component??
It's probably best to query for the top level component --> <div className = "card">
... BUT, we can't really query just for a div like that (unless we gave it an id or something?);
what we can do is change this "div" into an "article" which gives us some better functionality,
and lets us query by role, and use "article" as the role;

screen.getAllByRole("article")

and b/c there are 5 elements in the 'cats' array (our mocked data),
we can expect there to be 5 'Card' components or 5 'article' components -->
--> expect(screen.getAllByRole("article").length).toBe(5);

Our test won't pass yet, but we can check that it is failing by running
--> npm run test

@ #37  make the multiple 'Card' test pass in our code;
aka build out the "Cards" component code;

We basically iterate over the 'cats' json array/map (?)
and use the fields as properties for each 'Card' component we create;

create a Cards.css file in ~/components/Cards
then we need to import the Cards.css file into "Cards.js" to use the styles there;

@38 manual testing of the "Cards"
go to our App component --> "App.js"
& render our "Cards" component;

--> <Cards cats={cats}></Cards>
we have to put it in our "App" function, inside the return statement inside a div:
function App() {
  return (
    <div>
      <Cards cats={cats}></Cards>
    </div>
  );
}

and also we have to import both "Cards" & "cats" -->
import Cards from './components/Cards/Cards';
import cats from "./mocks/cats.json"

then we can check out the component by using:
npm run start

& we can see all the cat cards being rendered with the favorite buttons & pictures and info;
For some reason it is saying "return" at the top of my page though, and I don't know why;
I opened in chrome to check & it's the same as firefox...
maybe I have an extra 'return' statement somewhere...

@39  more complex user events --  --  --  --  --  --  --  --  --  --  --
now we are going to add the filtering component to our project
it should be pretty easy to do afa (as far as) the tests are concerned,
we just need to test that the selector/drop down component changes when we select a different value for it;

These tests will require us to use a new type of user input for when the user
chooses from the drop down menu (we have just used click & type so far)
mkdir ~/src/components/Filter
touch Filter.js
mkdir __test__
touch Filter.test.js

create assert/expect that will test that the intial value of drop-down/select component is "any"
/**
 * how the select will look (note the initial value should be "any"):
 * <select name="" id="">
 *  <option value="any">Any</option>
 *  <option value="favourite">favourite</option>
 *  <option value="not favourite">not favourite</option>
 * </select>
 */

We did a bunch of stuff, mainly just adding 2 'select' html elements
where we can choose favoured/not favoured && male/female
for which we wrote the tests FIRST, of course; We haven't integrated into the app yet;
---   ---   ---   ---   ---   ---   ---   ---   ---   ---   ---
@v41.

we're moving on to the "Pets" component which houses all the other components;
So far we have made all the individual components, but they are all separate at this point;
Bringing them all together & then testing them all together is non trivial
1. the pets component is going to be making http requests to get 'cats' data;
2. we're going to get that data back, then give it to the 'Cards' component;
3. getting this data is an asynchronous request, so we have to know how to deal with that in our tests;
4. we have to test multiple components--how these components work together aka: "integration testing" (we only tested on their own before aka "unit testing");
5. We'll start with the server side aspect, then we'll move on to the integration part;

@v42:
To make HTTP requests, we need a server.. but we're not building one for this course (we did in the nestJS crash course though)
but we still need a server of some kind; He attached a zip file to the video, DL & unzip it & put it in the same directory as the 'client'
I think that is where the folder is for the 'cat-adoption-app' (?)
We actually need to move all our current files & folders into a new folder called "client"
Then we need to create a new folder called 'server' and unzip this thing in there;
I did this and the 'client' stuff still works with --> 'npm run start'

cd into the 'server' dir & do an "npm i"

then we don't run 'npm run start' here, we do:
 "node index"

 which I am not familiar with but looks like it's telling node to run the "index" file--> "index.js"
 running 'node index' gives us -->       "listening"        back in the terminal  (where is it listening? which port?)
see the "index.js" file's app.listen function:

app.listen(4000, () => {
  console.log("listening");
});

we can open a browser and go to localhost:4000  & should see an error from the server--> "cannot GET /"
but if we go to http://localhost:4000/cats
we should get a big JSON array of 'cat' data; 👍

so what we're going to do is to make a request to localhost:4000/cats to get our 'cat' data for our App;
Since this class/tutorial is about react testing library, we are kind of skirting TDD here,
normally you would write the tests first, & then the implementation, but just this once we are going
to already have the implementation, & write the tests after 😉

----    ----    ----    ----    ----    ----    ----    ----    ----    ----    ----  --
@v43 -- "fetching data from our server"     ----    ----    ----    ----    ----  --  --

Now we'll start creating the "Pets" component;

cd ~/client/src/components
mkdir Pets
touch Pets.js

started writing some code--added divs in the Pets.js file;
touch Pets.css  for styling this file;
then we have to import the .css file into Pets.js;
next-- we need to show it (Pets.js)  the "Filter" and the "Cards"
so we create a <div> for each of those & add imports for them each;
THEN inside the "Cards" we need to pass in the "cats"

we want to check that we didn't break anything yet, so cd to client/
and run:
npm run start

it just runs what we had before, & that's b/c we need to tell our "App.js"
to render/use the "Pets" component --> that's going to be the only component that we
render in our App.js

If we change our App.js to only render this:   <Pets />  we get some errors & nothing renders;
What we can do to make sure our App is doing something, is to just pass in "cats" as an
object with an empty array, like this:
<Cards cats={[]} />

now our App will render at least the select component...
but without any styling.
So now we go to bootstrap.com
https://getbootstrap.com/docs/5.2/getting-started/introduction/
& copy the "CDN" link for CSS:
https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css

and add this to our index.html file:
<!-- link for bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">

that will style our 'select' component, and maybe some other stuff...?

we also add the import for the mocks/cats.json file to "Pets.js" and use that so we can see the component working;
It is working, although there's no gap b/t the 'select' and the 'cards' but we will fix that later;

-Next we want to make an HTTP request to get the 'cats' data instead of hard coding it from the /mocks folder;
TO do this, we will axios!!
You could use 'fetch' but axios makes http requests easier and is preferred by most & ∴ is more common;
so we have to 'npm i axios' inside the client directory;
& in 'Pets.js' we must add the import to use it there, ofc:
import axios from "axios"

cut everything from the 'Pets' function & put into a return statement;
remove the 'cats' from /mocks import and var
so we can create a useState hook again! with [cats, setCats]
and we'll have an async method called fetchCats!  so much stuff happening now;

holy hell, a lot of stuff;
Setting up that async method, a useState hook for the cats,
axios.get to get the cats data from localhost:4000/cats
and a new hook---> the "effect" hook in react;
see:
https://reactjs.org/docs/hooks-effect.html

we commented out the 'Cards' component from the 'Filter' div b/c it might error out right now,
and NOTE, we need to have our node server up,
so open another terminal window/tab, cd to /server and run:
node index

& we run "npm run start" from the 'client' folder and look at our browser;
Then we can look at our app & inspect the console to see that we have data coming! Pretty cool;

since we're getting data we can uncomment the 'Cards' component from 'Filter' component/div
and we should be getting our cats data to populate some 'Card' components in our App, which it is!
👍    👍

now we want to write a t'est that is identical to our 'Cards' test we did before, but now
we need to test it inside the 'Pets' component, and we're also using an async http request,
so we'll have to go over the issues that will come up trying to do this in the next section;

= _ = _ =_= _ = _ =_ = _ =_= _ = _ =_ = _ =_= _ = _ =_ = _ =_= _ = _ =_ = _ =_= _ = _ =

@v44 - 'writing a flawed test'

finally got back going... cloned his repo and pasted in my files and it works for some reason;
somehwere along the line I got a different module or did something wrong idk...
anyway, in this video we wrote a test that is relying on our node server running,
that's a big no no first of all; 2nd of all... idk, he said it's wrong;
we're not calling the server directly from the 'Pets.test.js' file, however, 
we are RENDERING Pets.js, which is then calling the server... 
so I'm not sure we want to be hitting our actual server to do our test; 
Maybe this is just for learning purposes?  But he did say this was a FLAWED TEST; 
anyway, the test will fail if the server isn't up; 

= _ = _ =_= _ = _ =_ = _ =_= _ = _ =_ = _ =_= _ = _ =_ = _ =_= _ = _ =_ = _ =_= _ = _ =

v45 "Issues with Making HTTP Requests in your Tests": 
what was wrong with our test? 
Like I said, the test is calling against the actual server; 
The test is dependent on the server working correctly and returning the same data every time; 
What if something went wrong with the server?  
Say we add this: 
throw an error in index.js before the "return res.json(cats)"
we restart the server; 
if we request to localhost:4000/cats at this point, we won't be getting any cats data; 
∴  if we run our tests again, the one testing the 'Pets' component will fail, b/c it is 
relying on the server being there to deliver some data; 

Why is this bad?     
1. We really want to test the front end logic, we're not trying to test
the back end in this test case.  If we were we'd call it 'testServer' or whatever, 
we are trying to test that our App is rendering some cards, not that the data is available 
from the server... get it? 
It adds other dependencies to our 'Pets' test; 

It's also possible that the data on the server could change; 

2. Calling our server costs money! $$$  ! ! ! 
The more tests we run (& the more server requests we make), the more money it will cost us!

3. Servers are slow (relatively).    If a single call takes a second or two, okay, doesn't sound too bad, 
but over hundreds of tests, that would take loads of time and add up, adding time, and cost to our project!

--> so what is the solution??  We can mock our server behavior! This will be faster and more effiecient, saving time & money!
we'll go over it in the next video!  ;-)

~        ~~        ~        ~~        ~        ~~        ~        ~~        ~
_____________________________________________________________________________

__v46. "Mocking HTTP requests with Mock Server Worker" ______________________

_____________________________________________________________________________

instead of making the actual HTTP request, it is better to mock the request and the data coming back
we could mock axios (or fetch if we're using that)
but according to Laith it's better to use 'mock service worker' than even mocking axios; 

The guy who created RTL actually reccommends using MSW over mocking axios directly, so that's a 
pretty strong endorsement!!

We need to install this (but I think it would already be there ?)  
it shoudn't hurt to do it again, (hopefully)  to do so: 
npm install msw

this changed the "package-lock.json" && 'package.json' files, 
also the yarn.lock file 

package-lock & package.json went from:
 "msw": "^0.36.3"  -->   "msw": "^0.36.8",

yarn.lock: 
"@mswjs/cookies@^0.1.6":
  "integrity" "sha512-A53XD5TOfwhpqAmwKdPtg1dva5wrng2gH5xMvklzbd9WLTSVU953eCRa8rtrrm6G7Cy60BOGsBRN89YQK0mlKA=="
  "resolved" "https://registry.npmjs.org/@mswjs/cookies/-/cookies-0.1.6.tgz"
  "version" "0.1.6"

  "@mswjs/cookies@^0.1.7":
  "integrity" "sha512-bDg1ReMBx+PYDB4Pk7y1Q07Zz1iKIEUWQpkEXiA2lEWg9gvOZ8UBmGXilCEUvyYoRFlmr/9iXTRR69TrgSwX/Q=="
  "resolved" "https://registry.npmjs.org/@mswjs/cookies/-/cookies-0.1.7.tgz"
  "version" "0.1.7"


we import these into our Pets.test.js file: 
import { rest } from "msw"    // to mock the rest component 
import { setupServer } from "msw/node"   // to setup a 'fake' server for our tests aka a 'mock server' 

I ran "npm run test" and everything is still working despite using a newer version of these packages, so that's good!

//here we can specify what we want to mock, what endpoint to mock, & what to return
const server = setupServer(
    rest.get("http://localhost:4000/cats", (req, res, ctx) => {
        ctx.status(200),
        ctx.json(catsMock)
    });
)

we want to mock http://localhost:4000/cats    which will be a GET request
we could also mock POST or PUT or whatever we want with this package "MSW"

1st param is 'what do we want to mock?'
2nd param is 'what do we want to return from that mock?'
    the callback has to take in a request, a response, and a context
we need our mock data again so we have to import that to our test file & use it in the rest call response (it's called "res") ..? ; 

    To use our mocked server we have to make our tests listen for it beforeEach test; 
    & since we want to always use it we'll actually use a "beforeAll" hook here; 
    then, after each test we want to reset the server essentially,
    and finally, after we're done with our tests, we want to close the mock server; 
* what that actually looks like: -->

        beforeAll(() => server.listen())
        afterEach(() => server.resetHandlers())
        afterAll(() => server.close())

as a sort of test of our mock server, we can remove one of the cats from the mockCats json array, 
and then our test should fail... let's check that real quick;

,
  {
    "id": 5,
    "name": "Rachel",
    "phone": "333-333-3333",
    "email": "laith@hotmail.com",
    "image": {
      "url": "https://images.unsplash.com/photo-1561948955-570b270e7c36?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxzZWFyY2h8NXx8Y2F0fGVufDB8fDB8fA%3D%3D&auto=format&fit=crop&w=800&q=60",
      "alt": "beautiful cat"
    },
    "favoured": false,
    "color": "grey",
    "gender": "female"
  }

we removed this last element and our now fails!  Wow--cool
So we don't have to acutally change our tests at all, it just uses the mocked server even if the real 
server is running!  How about that?!   Pretty neat. 

Now we can put this element back in the mocked data array so the test will pass; 


v47 -- 
now we want to test multiple components working together; 
so far we've really only tested the components in isolation... and we really need to test them working together; 
The different components need to interact in the actual app, so we need to test them togheter; 

* How do we do this?  
We need to test the parent component--the 'Pets' component; 
This is called 'integration testing' -- where we test how everything is working together; 

v48 -- 
writing the first integration test of our "Pets" component

1st thing we'll test is 'filter by gender'
This is easier than the other test we will need to write 'filter by favorites' 
The reason for this is that the gender is a prop in each card that is static, 
the favorites are not determined until the user clicks on stuff, so that adds another layer of complexity; 

moving on to writing the test-->
we add a beforeEach to render the 'Pets' component before each test; --> beforeEach(() => render(<Pets />)); 

ok, now I'm getting an error with the exact same test code as he used...F#CK 
""
● Test suite failed to run

    TypeError: Converting circular structure to JSON
        --> starting at object with constructor 'HTMLElement'
        |     property '__reactFiber$r2dibf7eha' -> object with constructor 'FiberNode'
        --- property 'stateNode' closes the circle
        at stringify (<anonymous>)

      at messageParent (node_modules/jest-worker/build/workers/messageParent.js:34:19)

must try it on his branch to see if something with my files again; 
and again, it works in his project, so i don't know if it's a dependencies problem 
or what;
Another things that's interesting is that it will run when I have the server running, 
so maybe I should just press on and hopefully it gets fixed with further coding; 
---------
v49 -- 
writing the logic to make our filter work--> 
looking at what's happening so far:
we have our 'cats' state (which is initially an empty array)
then we have the useEffect that is called on render()
that useEffect is calling fetchCats() which is getting the cats data from the server, 
and setting that cats state as the response; 

then we're passing the cats data to the 'Cards' component, and that is rendering each 'Card' comp.

What we need to do is somehow filter the cats in the fetchCats/setCats stage, & pass in 
whatever filtered cats we want to show to the part where we're rendering stuff; 

Laith suggests we have another state for the filters;

We add another useState with the needed 2 fields, and we'll use 'filters' & 'setFilters'
This will be equal to an object with prop. "gender" initially set to 'any'
And what we'll need to do is find a way to update this prop ('gender') any time 
we change the filter component's value with the drop down list; 

To do this we can pass the filters useState to the 'Filter' div component; 
Then we need to 'accept' them in our Filter.js code, 
b/c this is where the actual component is defined; 

Then for the 'gender' 'select' component (select is what the drop down menu is called in html)
we need to have an 'onChange' callback, (and maybe use 2-way binding ?) 
we have a function, where we set the 'setFilters' value as whatever is in 'filters',
but we replace the 'gender' prop. with whatever value that's coming in from the 'onChange' 
like this: 
<select name="gender" id="gender" className="form-select" onChange={(e) => {
            setFilters({
                ...filters,
                gender: e.target.value,
            });
        }}>

we added a console.log under where the 'filters' value gets assigned in 'Pets.js'
and looked at/inspected the console from the browser (after launching our app)
It updates the print out & ∴ the 'filters' value when we select male/female
so that part is working--good; 
The provenance of this value is something like this: 
We have a Filter component/class defined
in that Filter, we have the logic to update the value of 'gender' onChange; 
We have our 'Pets' class/component which has a 'Filter' in it;
In the 'Pets' component we also have a 'useState' logic where 'onChange'
we udpate the value of the 'gender' property inside of setFilters,
 which then goes into 'filters'...?  useState stuff is a little hard to 
 follow completely from a to b, but you get the idea, right? 

So when that filter gets clicked on, we want to update the 'cats'
array, but NOT our original cats array, no no no, that is our 
absolute truth array, we don't want to mess with that; 
Laith calls it our "source of truth" .. not sure if that is a scientific term or not; 

*    *    *    *    *    *    *    *    *    * 

-I think this is a scientific term; 'source of truth'
aka 'single source of truth'  aka 'SSOT'

example: 
starting array: 
[male, female, male, female, female]
if we filter for just males, then we'd have:
[male, male]
then if we filter for females after that, we won't find anything; 
[]
Then we just have an empty array, no males or females; 

*    *    *    *    *    *    *    *    *    *

We need a copy of the original array pretty much, where we can mess with the values etc; 
We actually need to duplicate it each time we want to filter; 
@3.30 of v49

To do this we will need yet another state in Pets.js (!) So many states!
We set up another 'useState' which will be an empty array,
(exactly like our original useState [cats, setCats])
like this:    const [filteredCats, setFilteredCats] = useState([]);

we want to also set this to the cats data initially, just like the other one
inside our fetchCats() function; 

Then we want to pass in the 'filteredCats' to our 'Cards' component 
so those are the only ones to get rendered, JUST LIKE WE WANTED!!
It doesn't work yet though... 
We need to actually filter those cats any time we have a change on the filters!

So we'll add another 'useEffect' in Pets.js
We start off defining our duplicate array of the cats --> 'catsFiltered'; 
we have an IF statement, where if there is a filter selected, 
we just pick the cats that match that filter; 
then we call our 'useEffect' to setFilteredCats(catsFiltered) "set filtered cats to 'catsFiltered'"
AND... I still need to do some more examples of useEffect b/c this is 
very new syntax to me; 

But our tests should pass now!  but we have a fail, I think we didn't import it; 
Actually we just need to pass the props to our Filters test file... ; 
We can do this in a beforeEach 

He actually ran into the same error I had before "TypeError: Converting circular structure to JSON"
and I didn't even have the female test in Pets.test.js, so that's why I didn't get it again; 
I wonder if it will pass now without the server running ? 
yup.

ok, moving on to v50

v50 -- 
now we have the logic for filter by gender, and we want to add logic for filter by 'favoured'/'not favored'
It's a bit harder b/c we don't have any values until after the user clicks on the little heart buttons; 
in other words--
render the cards, select the cards we want to favorite, THEN we can filter for them; 
Default behavior is if nothing selected then if we choose 'favoured' it will show no cards, 
if we choose 'not favoured' it will show them all (b/c no cats/cards have been 'favoured')

our test with notes: 
  
  test("should filter for favoured cats", async () => {
    //first we need to find all the cards
    const cards = await screen.findAllByRole("article");
  //  then we need to start clicking favoured on some of the cards
  //  how do we do that?  You might think, 'easy, we just find the button for the cards we want to favour'
  //  but how do we find the button for a specific card, Holly for example? 
  //  we can't getByRole("button")  b/c that will return multiple buttons --> error
  //  we could try something like --> 
  //  const buttons = await screen.findAllByRole("button");  
  //  buttons[0]  to access the specific buttons... (& this would work) BUT... what if we added more buttons to our app later? 
  //  so what do we WANT to do?  We want to look at a card and find the button within it... and we can do just that with RTL   
 //  but how?    We can use "within" from RTL

  // this will get us the "button" element that is 'within' the component we passed --> cards[0] a JSX element/component  
    // const btnForFirstCard = within(cards[0]).getByRole("button");
    // const btnForFourthCard = within(cards[3]).getByRole("button");
    // //now we just need a userEvent to click on those buttons
    // userEvent.click(btnForFirstCard);
    // userEvent.click(btnForFourthCard);
    // we can just skip the variables and use those within() calls inside our userEvent()`s 
    // the fact that we find a card, then find an element within that card, means we are
------------   ------------   ------------   ------------   ------------   ------------
    --- using a NESTED QUERY for RTL --- >    within(cards[0]).getByRole("button")
------------   ------------   ------------   ------------   ------------   ------------
    userEvent.click(within(cards[0]).getByRole("button"));
    userEvent.click(within(cards[3]).getByRole("button"));
    userEvent.selectOptions(screen.getByLabelText(/favourite/i), "favoured");
    expect(screen.getByRole("article")).toStrictEqual(cards[0], cards[3]);
  });

v51 --
now we will add the logic to make our favoured/not favoured tests pass 
It will be a little less trivial than the gender filter; 

1. we're going to get the "setCats" function, and pass it to the 'Cards' JSX element within the 'Pets.js'
   --> we also have to pass it into the Cards.js file where we declare the 'const Cards' like this: const Cards = ({ cats, setCats }) => { .......

2. add a function called "updateFavourite" in our "Cards.js"   

            const updateFavourite = (index, favoured) => {
                    //initially gets the value of the cats array... we use the 'spread' operator prefix--> "..."
                    const updatedCats = [...cats]; 
                    // update the array at that index with the favoured value that was passed to us; 
                    updatedCats[index].favoured = favoured; 
                    // then we set the cats to the updated array, and this way we can update the favourite status when it gets changed 
                    setCats(updatedCats)
                }

3. Then we have to pass this function into the 'Cards' component, b/c this is where we're gonna call this function; 

4. we also have to pass in the index to 'Cards' ...
as we declare a new 'Cards' component, we pass in a map of the 'cats' array/data; 
this lets us iterate over the array I believe... (?)
In doing this, we have to call an anonymous function, which we pass in 2 things now--> "cat" & "index"
I think the "cat" component is just the singular that we use to iterate on the map;
and now we want to pass in the "index" as well so we can access it later with the "updateFavourite" function; 
and it looks like the syntax of iterating on the "cats" we declare the properties, 
and we set them to the values of the props in our singular "cat" like this --> name={cat.name}
and in a similar way we assign the index -->  index={index}

5. we need to go into the "Card" component
    we need to pass in the index & updateFavourite function to our new "Card"
    and for our "toggleFavoured" function, we want to call "updateFavourite(index, !isFavoured)"
    which passes the index of the "Card" 
    and toggles the "isFavoured" value true/false

like this------------------->

const Card = ({ name, phone, email, image, favoured, index, updateFavourite }) => {
    //setting up a localState w/ initial value from our props that came in with anon func
    const [isFavoured, setIsFavoured] = useState(favoured);
    const toggleFavoured = () => {
        updateFavourite(index, !isFavoured)
        setIsFavoured(!isFavoured);
    };




6. We also added a console.log(cats)  after our declaration of the "Pets" component, 
   so when we click on something, "Pets" gets rendered again, and this will call our console.log 
   & give us the (hopefully) updated values of the cats array;
   * note that we didn't need to create a duplicate array this time, b/c this property "isFavoured"
   is designed to be used this way, and it's okay with this property...
   as far as a breakdown of why this is okay and not with male/female... I'm not 100% sure at this point, 
   but we can circle back to this;


------------
@5.02 of v51 
NOW----- some of our tests should fail;
These 3 fail: 
● Pets › should filter for not favoured cats
● Pets › should filter for favoured cats
● Card › Should toggle heart status

B/c we passed in a new prop "updateFavourite" to our "Cards" component, which in turn gets called by the "Card" component, 
we ALSO have to update our "Card.test.js" file, and update our test with this prop as well;

so we went from this: 
                        const cardProps = {
                            name: "Sydney",
                            phone: "555-555-5555",
                            email: "drew@gmail.com",
                            image: {
                                url: "https://i.natgeofe.com/n/548467d8-c5f1-4551-9f58-6817a8d2c45e/NationalGeographic_2572187_2x1.jpg", alt: "cute cat"
                            },
                            favoured: false
                        }

to: 

                        const cardProps = {
                            name: "Sydney",
                            phone: "555-555-5555",
                            email: "drew@gmail.com",
                            image: {
                                url: "https://i.natgeofe.com/n/548467d8-c5f1-4551-9f58-6817a8d2c45e/NationalGeographic_2572187_2x1.jpg", alt: "cute cat"
                            },
                            favoured: false,
                            updateFavourite: () => {},
                            index: 1,
                        }

He doesn't really go into why we just set it as an empty function & index of 1, 
but this should bring us down to only 2 failed tests;

----------------------
in "Pets.js" 

we have to pass in the "favoured" property, which we can initially set to "any" 
like this: 
                const Pets = () => {

                const [cats, setCats] = useState([])
                const [filteredCats, setFilteredCats] = useState([]);
                const [filters, setFilters] = useState({
                    gender: "any",
                    favoured: "any"
                });

then, in our "useEffect" regarding the filters, we add an IF block

if(filters.favoured !== "any") {
    //do something similar to what we did when we filtered by gender
}

we tried that and it didn't work  -- why??
B/c we need to update the "favoured" inside the "Filter" component as well
and add another 'onChange' function in the "select" div of "Filter.js" 
we can use a ternary operator, (even though he put them in the wrong order and gave up on it)
like this: 
            onChange={(e) => {
                setFilters({
                    ...filters,
                    favoured: e.target.value === "favoured" ? true : false,
                });
            }}

but let's see how else we can accomplish the same thing;

We moved this logic over to Pets.js in the 'useEffect' for the filters like this --> 

                if(filters.favoured !== "any") {
                    // our first try: 
                            //debug: 
                    catsFiltered = catsFiltered.filter(
                    (cat) => {
                        console.log(cat.favoured, filters.favoured, cat.favoured === filters.favoured);
                        return  (cat.favoured === (filters.favoured === "favoured" ? true : false));
                    }
                );

This works, but maybe we'll refactor it later to keep the logic inside the 'Filter' component...
and the next video's title is 'fixing a typo' so we'll see in v52--WE ARE ALMOST DONE!!

v52 --
in "Pets.test.js" we had a typo in the expect/assert for test("should filter for favoured cats" ....
we had `getByRole("article")`
and we needed to have `getAllByRole("article")`  b/c we are looking at more than one element, & if we get more than one
with the standard "getBy" test/expect/assert ---> error  

same thing for the other test as well, test("should filter for not favoured cats"


All our tests should pass now, but I am AGAIN getting this darn error: 
● Test suite failed to run

    TypeError: Converting circular structure to JSON

it's something in the last two tests (that we just 'fixed') in Pets.test.js

I can try pasting in his code and see if that fixes it ...
and his tests do work, so maybe I still have another typo in there somewhere, 
let's find out what it is and then move on to v53!



v53 --
time to complete our testing suite by testing for 
'filter by favoured && gender'

in Pets.test.js

so made our last test where we select 'favoured' on a male & a female cat, 
then we select the 'male' from the 'gender' select drop down
& select 'favoured' from the 'favourite' select drop down

then we expect/assert that we only get back the one card that should remain of the two; 

This pretty much tests all the functionality of our app! and it passes, so I guess we're done
expect we can refactor & clean up our app a bit; 

and fix the styling/spacing issues in the app; 

v54 -- 
To fix the styling on our app we need to create a Filter.css file; 
that i already seem to have..

I wasn't actually using it though, we needed to add the import in "Filter.js" like this: 
import "./Filter.css"

& now there is some padding around the filter so it all looks better 👍

v55 --
refactor our code to use the "context" API 
I don't know what this is, so sounds interesting; 

So the way that we'll manage state throughout our app will be through using this context API; 
Instead of being passed in from one component to another component (by props); 
This shouldn't change the functionality of our Application...
only the implementation details
--> So our tests should still pass, right? B/c we're not testing the implementation, rather, 
we are testing how the app works as the user interacts with it (as we should be testing it);

in "Pets.js"
so import "createContext" from "react" 

then we declare a new context called "PetsContext", & we pass in 
cats: [],
setCats: () => {}

like this: 

        const PetsContext = createContext({
            cats: [],
            setCats: () => {}
        });

Then we wrap the 'Filter' & 'Cards' components with a "context provider"
and we also need to provide the values that match where we declared the context 
with "createContext"
we can specify the values we pass in here, and we want to use the "filteredCats" useState
b/c this is the array with all the filters applied (the cats we want to show respecting the filters)
and "setCats" we just use "setCats" ... b/c I guess this is the 'setter' part of the useState (?)
like this: 
            return (
                <div className="container">
                <div className="app-container">
                    <PetsContext.Provider value={{ cats: filteredCats, setCats }}>
                        <Filter filters={filters} setFilters={setFilters}/>
                        <Cards cats={filteredCats} setCats={setCats}/>
                    </PetsContext.Provider>  
                </div>

                </div>
            )

Then, to actually USE this context, we need to export the "PetsContext" from "Pets.js"
like this: 
            export const PetsContext = createContext({
            cats: [],
            setCats: () => {}
            });

and then we can access this context ('cats' & 'setCats') in "Cards.js" 
by using the "useContext" hook (which should get auto-imported)
like this: 
            const { cats, setCats } = useContext(PetsContext);

Since we will have this useContext, we can get rid of the props we were passing in to 'Cards.js'

from: 
                const Cards = ({ cats, setCats }) => { .....
            
to: 
                const Cards = () => {  ........

and remove them from the 'Cards' JSX in 'Pets.js'
from: 
        <Cards cats={filteredCats} setCats={setCats}/>
to: 
        <Cards />

And everything should still work okay ...

----------

So now we want to do the same thing for the 'Card.js'/ Card component 

we will add the 'useContext' hook inside 'Card.js' 
& make sure everything auto-imports--easy way is to copy paste it in, 
remove a letter & let it autocomplete & autoimport them; 

const { cats, setCats } = useContext(PetsContext);

but he says we only care about the "setCats" inside 'Card'
so we can remove 'cats' 

const { setCats } = useContext(PetsContext);

and move the 'updateFavourite' function from 'Cards' ---> into 'Card'

        const updateFavourite = (index, favoured) => {
            const updatedCats = [...cats]; 
            updatedCats[index].favoured = favoured; 
            setCats(updatedCats)
        }

and then we don't need the 'updateFavourite' property as we declare our 'Card' any more, so remove that 
from: 
        const Card = ({ name, phone, email, image, favoured, index, updateFavourite }) => { ........
to: 
        const Card = ({ name, phone, email, image, favoured, index }) => {

so then we don't need to pass in 'updateFavourite' in (from?) 'Cards.js' 
and then we can remove 'setCats' from the context altogether (inside 'Cards.js')
we still need both the cats & setCats context for 'Card.js'

and everything should still work (in the app anyway) now, which it does, so that's good; 
The tests may have suffered, so lets try those also; 
looks like 2 tests are now failing despite our app seeming to work fine see:
 
 FAIL  src/components/Cards/__test__/Cards.test.js
● Cards › should render five card components


 (src/components/Card/__test__/Card.test.js:83:20)
 ● Card › Should toggle heart status

 v56 --  'adding a mock provider to our tests'
 
 THE LAST VIDEO YOU GUYS!
 Now we'll talk about why these tests failed and what to do about it; 
He actually mentions what I have already learned at this point, which is that
we can run individual files with 'npm run test' by appending the file name
at the end like 'npm run test myFile.js'
so let's do that for Pets.test.js
npm run test Pets.test.js  --> pass
npm run test Filter.test.js  --> pass
npm run test Cards.test.js  --> 2 fail, can't find the cards is the root problem, 

test("should render five card components", () => {
       6 |         render(<Cards cats={cats} />);
    >  7 |         expect(screen.getAllByRole("article").length).toBe(5);
         |                       ^
       8 |     });
       9 | });

and this makes sense, b/c in our test we were passing the cards as props, 
and we have updated the app so the cards are in the contextProvider

So we need to refactor our tests to utilize the contextProvider rather than props

This is a sort of red herring, our test is still testing the functionality of the app, 
we just had the test written to use our implementation... I guess
We always want to test the functionality though! 

so where we had in Cards.test.js: 
                render(<Cards cats={cats} />);

we can use the PetsContext like this: 
        render(<PetsContext.Provider value={{
            cats, 
            setCats: () => {},
        }}>
            <Cards />
        </PetsContext.Provider>)

now the 'Cards.test.js' is okay, so we try 'Card.test.js' 
npm run test Card.test.js

and that has a failing test in there; 

we had: 
       // render the Card & pass in some props
        render(
            <Card
                //spread the props from a variable instead of manually adding the props here:
                {...cardProps}
            />
        )//render


we could do this each time we want to render a card: 
        //use the PetsContext instead of just render the Card: 
        render(
            <PetsContext.Provider value={{cats, setCats: () => {}}}>
                <Card {...cardProps} />
            </PetsContext.Provider>
        )


-- BUT -- 

this has to be done each time we render a Card... 
so we can write a helper function to make it easier; 










~    ~    ~    ~    ~    ~    ~    ~    ~    ~    ~    ~    ~    ~
____________________________________________________________________

∴   ●   ↓   →   ←   ↔    ▲    ▼    ►    ◄   👍   😉

his repository:
https://github.com/harblaith7/React-Testing-Library-Udemy-Course

